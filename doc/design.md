诸葛神码代码库向量索引模块概要设计说明书V1\.0


深信服科技有限公司


目录

0\.设计方法参考	6

1\. 介绍	6

1\.1\. 目的	6

1\.2\. 定义和缩写	6

1\.3\. 参考和引用	7

2\. 设计任务书	7

3\. 对外接口	9

3\.1\. API接口	10

3\.2\. 消息接口	10

4\. 概要说明	11

4\.1\. 背景描述	11

4\.1\.1\. 工作原理	11

4\.1\.2\. 应用场景	11

4\.1\.3\. 对手分析	11

4\.2\. 方案选型	12

4\.3\. 静态结构	13

4\.4\. 对软件总体架构的影响	13

4\.5\. 概要流程	13

4\.5\.1\. 流程1\(改成具体的流程名字\)	13

4\.5\.2\. 流程x\(根据需要可自行添加章节\)	14

4\.5\.3\. 可调试性机制分析及设计	14

4\.5\.4\. 可测试性机制分析及设计	14

4\.5\.5\. 可扩展可复用设计	14

4\.5\.6\. 系统隐私设计	14

4\.5\.7\. 安全性设计	15

4\.5\.8\. 可靠性设计	15

4\.5\.9\. 可维护设计	16

4\.5\.10\. 跨平台设计和平台差异处理	17

4\.6\. 方案风险分析	17

5\. 数据结构设计	18

5\.1\. 配置文件定义	18

5\.2\. 全局数据结构定义	18

6\. 流程设计	18

6\.1\. 子模块1/类1/主题1	19

6\.1\.1\. 静态结构	19

6\.1\.2\. 处理流程	19

6\.1\.3\. 关键算法描述	19

6\.1\.4\. 数据结构定义	19

6\.1\.5\. 函数列表	19

6\.1\.6\. 设计要点检视	20

6\.2\. 子模块2/类2/主题2	21

7\. 总结	21

7\.1\. 关联分析	21

7\.2\. 遗留问题解决	21

8\. 业务逻辑相关的测试用例	21

9\. 变更控制	22

9\.1\. 变更列表	22

# <a id="_Toc6263"></a>0\.设计方法参考

概设的输入：总体设计里面划分好的某个具体模块、该模块需要实现的对外接口、该模块的系统流程；

 开始撰写前，画出一个方案的大体思路交给专家评定（画一些图示等）。

概设的输出：设计该模块的全局的数据结构（包括结构体定义）、接口流程图、实现接口的所有内部函数（功能、流程图）

如果一个模块比较大，还可以划分小的模块来并行设计，可以在“概要说明”章节里面再划分子模块，分别分配给不同的人员进行设计，再合并成一份文档，但必须有一个人负责模块的总体概要设计，对本模块概要设计负总责。

*模块设计方法参考：*

<a id="_MON_1702450840"></a>*设计常用表格： *

<a id="_MON_1702457103"></a>*模块设计特性参考：*

<a id="_MON_1702457056"></a><a id="OLE_LINK1"></a><a id="_Toc3756"></a># 介绍

<a id="_Toc8879"></a>## 目的

简要介绍该设计要解决的问题（满足用户什么需求或者解决现有设计什么问题）。

	此模块在诸葛神码 AI 编程助手的服务端里发挥着关键作用，其主要功能是构建并提供用户代码仓库的上下文信息。借助向大模型的 Prompt 注入代码库相关背景知识，能够有效提升 AI 生成代码的质量。模块具备基于语义的相似度检索、基于代码元素关系的检索以及代码库上下文信息更新这三大核心能力。

核心价值剖析：

- 增强大模型理解能力：把代码的结构、元素间关系等专业知识融入提示词，有助于大模型更精准地理解用户需求。
- 提升代码生成质量：精准的代码上下文能让 AI 生成的代码更贴合实际项目情况，减少错误的出现。
- 优化开发体验：基于关系的影响分析可以提前发现潜在问题，语义检索能帮助开发者快速找到所需代码片段。

关键场景定义：

- 基于语义的检索。比如用户提问 “仓库中的用户注册的相关代码有哪些？”；
- 基于代码元素关系的检索。代码元素包括文件、包、命名空间、类、接口、函数、变量等，关系包括引用、依赖、继承、实现等，比如用户提问“修改当前函数，会对哪些代码产生影响？”；
- 代码库上下文信息更新。用户的代码会一直更新，代码上下文也需要进行更新。

<a id="_Toc430139183"></a><a id="_Toc3439"></a>## 定义和缩写

定义或解释本文档中使用的所有专用名词和缩略语。

名词或缩写

定义

诸葛神码

深信服—AI效能部开源的AI编程助手。

RAG

‌Retrieval\-Augmented Generation，是一种结合了语言模型和信息检索技术的前沿技术，旨在通过检索相关文档来增强生成模型的性能和准确性。RAG模型在生成文本或回答问题时，会先从文档集合中检索相关信息，然后利用这些信息来指导文本的生成，从而提高预测的质量和准确性‌。

Prompt

prompt中文为“提示词”。在AI大模型中，Prompt的作用主要是给AI模型提示输入信息的上下文和输入模型的参数信息。

REST

REST是一种基于HTTP协议的软件架构风格，利用HTTP协议的各种方法（如GET、POST、PUT、DELETE等）来执行资源（数据对象）的操作

GraphQL

‌GraphQ‌是一种用于API的查询语言，由Faceboo开发并于2015年开源。它旨在提高客户端应用程序的数据获取效率，通过定义数据的类型和结构使得API更加灵活和可扩展‌。GraphQL的核心思想是用一个API代替多个API，客户端可以通过一个GraphQL请求获取所需的所有数据，而不需要调用多个API或进行多次请求。这种设计减少了不必要的数据传输和处理，提高了API的效率和可用性‌。

<a id="_Toc30920"></a>## 参考和引用

列出本文档编写过程中参考的其它文档或资料

1. 参考需求文档的哪些章节
2. 参考总体设计文档的哪些章节
3. 参考的其他文档

       参考总体设计文档 《诸葛神码开放性架构\-技术点方案》

<a id="_Toc5152"></a># 设计任务书

本设计目标书在设计开始前由总体设计人员填写下发给概要设计人员，责任追溯时，如果任务书不完整有遗漏，则为总体设计人员的责任。

概要设计人员遵照任务书要求完成设计，需自行检查是否达到任务书的要求，在“自检”这一列填写是否通过（如对于需求点，需指明相关描述所在的章节号）。

性能目标和整体目标不允许写“与XX相同”一类，如果与别的项目（或版本）相同，就把别的项目（或版本）的指标复制到这里。

1\. 需求跟踪（必须覆盖需求矩阵中与本模块相关的所有需求点）

__编号__

__需求点名称__

__需求点说明/验收条件__

__自检__

1\.1

基于语义的相似度检索

需求说明：

  使用自然语言进行相关代码片段的检索。

（1）查找特定功能的实现。例如 “数据库连接池配置”。

（2）定位使用了特定技术的代码。像 “Hibernate 相关代码”。

（3）搜索遵循特定设计模式的代码。例如 “单例模式的实现”。

验收条件：

针对语义检索，要进行 100 个以上的测试用例验证，准确率需达到 70% 以上。

1\.2

基于代码元素关系的检索

需求说明：

   输入代码元素，查找与它相关的代码片段。

 （1）影响分析：当修改一个公共函数时，能确定哪些模块会受到波及。

（2）依赖追踪：找出某个类的所有子类或者某个接口的实现。

（3）调用链分析：获取某个函数完整的调用路径。

验收条件：

    对于关系检索，要能正确识别至少 80% 的跨文件引用。

1\.3

代码库上下文的更新

需求说明：

    客户端代码库代码文件的更新，需要同步到服务端，更新上下文索引库。

    （1）增量更新：只处理变更的文件相关的索引，提高更新效率。

    （2）同时支持新增、修改、删除三种场景的上下文所索引库更新。

验收条件：

    （1）单个代码库全量上下文构建平均控制在5min。

    （2）增量更新单个文件的索引，控制在30s。

2\. 模块整体目标

__编号__

__目标项概述__

__对应的评审标准__

__自检__

2\.1

性能

索引构建时间

（1）向量构建：按10万行代码规模，每50行生成一个向量，总共2000个向量，RTX4080（16G显存）部署嵌入模型，单个项目10秒全量构建。

（2）关系构建：按10万行代码规模，解析\+存储控制在10秒以内。

检索延迟

1. 语义相似度查询：时间控制在1s以内。
2. 基于关系的检索：需要遍历图结构，深度限制不超过10层，时间控制在1s以内，补全500ms以内。

并发索引构建数

采用RTX 4080（16G显存）部署，按单个实例能并发处理10个，部署4个实例，并发处理40个。  

并发检索数

支持100个并发查询，多余查询进行排队，超过一定队列长度进行拒绝。 

其它

2\.2

资源开销

内存占用

1、单Pod 4核8G，依据压力情况横向伸缩；

DISK占用

1. 向量存储：按单个项目10万行代码，每50行代码一个向量，嵌入维度1536维，以单精度32位存储（4字节），则占 10万 / 50 \* 1536 \*  4 = 11 MB；100个项目，约占用 1GB。（
2. 调用链存储：以文本形式存储在数据库中。按50万行代码，存储完整的定义和调用链关系，PostgreSQL 数据库大小约为 100\-500 MB（包含索引）； 100个项目，约占用 10G ~ 50 G\.  

其它

2\.3

稳定性/可靠性要求

长时间稳定提供服务需要的保障，异常时提供的使用保障，等等

1. 基于k8s 进行部署，使用k8s 故障恢复机制，确保服务可以故障重启； 
2. 服务采用多副本部署，避免单点故障；
3. 数据库采用主从复制，读写分离架构；
4. 服务提供探活接口/health，基于k8s  readniess、liveness 机制进行探活，必要时自动重启服务；

2\.4

兼容性

部署平台

1、仅支持通过docker\-compose 或 kuberntes 容器化部署。

2\.5

可扩展性

哪些功能或接口需要可扩展设计

1. 向量数据库需要支持可替换；
2. 嵌入大模型需要支持可替换；

2\.6

安全性

防止被越权使用或者成为攻击点

1、上下文检索，检索范围仅限于当前当前用户所属的项目，用户之间需要做隔离；

2\.7

其它

 3\.流程要求

该文档是否需要外部评审？

*按设计流程要求*

审核人签名

 

时间

 

<a id="_Toc18788"></a># 对外接口

描述本模块对外提供的软件接口，即是该模块的需要实现的需求功能之一

需要提供哪些对外接口，是从总体设计里面分解模块得到的，这里可以拷贝总体里面该模块的外部接口列表。

如果本模块支持自动化测试，需要实现对应的自动化测试接口，也需在“对外接口”中明确下来。

模块的对外接口，需要遵守公司定义的API规范。如果现有规范无法覆盖需求，需要组织干系方讨论需求，提取新的规范接口并评审，参考流程：[http://code\.sangfor\.org/sangfor/specification](http://code.sangfor.org/sangfor/specification" \l "流程规范)

__引用规范的名称__

__应用模块（下面模块设计里的某个模块）__

__代码实现（如果使用公共代码列出公共代码引用位置，如果自研代码描述自研代码相关信息）__

__备注（约束要求，例如性能要求，接口自动化测试要求）__

各产品线API对接规范V1\.0之弹窗提醒\.doc

联动提醒模块

自研Python代码，发布时将此模块抽取成公共模块给公司其他产品线复用。

能支撑并发20个用户同时提示；用户不在线时支持重试；支持多个消息合并。

<a id="_Toc30050"></a>## API接口

Api接口：以api或rpc等形式提供的外部接口。

如果未对外提供API接口，本章节可以删除。

### 获取上传令牌（过载保护）

__接口定义__

__请求头__

- __Authorization__：Bearer token（jwt token）

__请求参数__

参数名

类型

是否必选

描述

clientId

string

是

客户ID，machineID

codebasePath

string

是

项目绝对路径（按照操作系统格式）

codebaseName

string

是

项目名称

响应参数

__参数名__

__类型__

__描述__

code

int

状态码，200 表示成功获取令牌，非 200 表示获取失败，可根据具体错误类型定义不同的状态码，如 503 表示服务已满。

message

string

状态码描述信息，如 "令牌获取成功" 或 "服务已满，无法获取令牌"。

data

object

响应数据，若获取令牌成功，包含令牌信息，如 \{"uploadToken": "xxxxxx"\}；若服务已满，包含当前使用用户个数，如 \{"userCount": 100\}。

__响应示例__

__服务已满，获取令牌失败__

### 新增代码向量

__接口定义__

__请求头__

- __Authorization__：Bearer token（jwt token）

__请求参数__

参数名

类型

是否必选

描述

clientId

string

是

客户ID，machineID

codebasePath

string

是

项目绝对路径（按照操作系统格式）

codebaseName

string

是

项目名称

uploadToken

string

是

由获取上传令牌，当前调试万能令牌"xxxx"

extraMetadata

object

否

额外元数据（键值对）

file

file

是

项目变更文件列表：\.shenma\_sync/timestamp  
文件二进制内容 zip压缩下。

chunkNumber

整数

否

当前分片

totalChunks

整数

否

分片总数，当代码过大时候采用分片上传（默认为1）

fileTotals

总数

是

上传工程文件总数（核验进度）

__响应示例__

\.shenma\_sync/timestamp  不要换行，不要有空格，减少空间占用。

文件包解压后信息

### 向量构建状态查询

注:该接口用于上传过程中状态查询。

__接口定义__

__请求头__

- __Authorization__：Bearer token（jwt token）

__请求参数__

参数名

类型

是否必选

描述

clientId

string

是

客户ID，machineID

codebasePath

string

是

项目绝对路径（按照操作系统格式）

codebaseName

string

是

项目名称

chunkNumber

整数

否

当前分片

totalChunks

整数

否

分片总数，当代码过大时候采用分片上传（默认为1）

__响应示例__

### 代码库对比接口

__接口定义__

__请求头__

- __Authorization__：Bearer token（jwt token）

__请求参数__

参数名

类型

是否必选

描述

cliendId

string

是

客户ID，machineID

codebasePath

string

是

项目绝对路径

__响应__

第一次启动或异常中断时和服务端对比 目录树hash，判断哪些文件没有同步，哪些文件被修改了，哪些被删除了。

服务器当前项目的目录树hash， 客户端对比，判断要传哪些文件。

过程中，不用请求服务器继续对比，可以放本地临时文件中, 里面存个时间戳字段，代表上次同步时间，判断当前间隔，如果过长，还是从服务器获取，否则就以本地的上次同步状态为准。减少和服务器的目录hash的频率以及客户端扫描目录的频率。

###  语义检索检索接口

注：改接口改为post接口，避免url编码问题，另外添加score参数过滤检索相干性低结果，5秒，平均1秒内

POST  /codebase\-embedder/api/v1/search/semantic

请求头：Authorization: Bearer tokenxxxxxxxxxxxxxxxxxx  （jwt token，包含用户信息）

- __请求方法__：POST
- __接口版本__：v1
- __请求格式__：JSON
- __响应格式__：JSON

请求参数

__参数名__

__类型__

__必选__

__描述__

clientId

整数

是

用户机器id（可以用mac地址等）

codebasePath

字符串

是

代码库的绝对路径

query

字符串

是

查询关键词，用于语义搜索的文本内容

topK

整数

否

返回结果的数量，默认为 10

scoreThreshold

浮点数

否

最低分数，默认0\.3

返回：

### 获取一个代码库的索引情况

注：返回接口添加isFullExtraction，用于区分是否支持部分检索，该结构可以用于构建完成后的统一信息展示

GET  /codebase\-embedder/api/v1/embeddings/summary

- 请求方法：GET

__请求头__

- __Authorization__：Bearer token（jwt token）
- 接口版本：v1
- 响应格式：JSON

请求参数

__参数名__

__类型__

__位置__

__必选__

__描述__

clientId

整数

Query

是

用户机器id（可以用mac地址等）

codebasePath

字符串

Query

是

项目的绝对路径

返回：

第二次构建、闲时

### 删除向量

接口信息

- 接口名称：删除指定代码库中的嵌入数据（支持删除整个代码库或特定文件）
- 请求方法：DELETE

__请求头__

- __Authorization__：Bearer token（jwt token）
- 请求 URL：/codebase\-embedder/api/v1/embeddings

请求参数

__参数名__

__类型__

__必填__

__描述__

clientId

String

是

用户机器id（可以用mac地址等）

codebasePath

String

是

代码库的完整路径（需 URL 编码），指定要操作的代码库

filePaths

String

否

需删除的具体文件路径（多个文件用逗号分隔）。若不填，则删除整个代码库的嵌入数据

请求示例

返回示例

成功率配置

给用户展示构建状态

## 消息接口

消息接口：以进程/实体间传递的消息为接口

如果未对外提供消息接口，本章节可以删除。

    无消息接口。

<a id="_Toc22186"></a># 概要说明

<a id="_Toc26270"></a>## 背景描述

<a id="_Toc21612"></a>### 工作原理

#### 工作流程


                                                                                     与其它模块/组件之间的交互关系      

- 源文件存储：源文件存储在文件/对象存储中，路径为   /$\{base\_path\}/<用户唯一标识base64编码>/<用户machine\+id项目路径base64编码>/代码文件或目录   \(name、邮箱、手机号hash\)
- 向量存储：向量数据库；
- 代码元素关系存储：关系型数据库；
- redis：本模块会采用多副本部署，多进程之间的消息传递、同步使用redis；
- AI网关：大模型代理；
- 嵌入模型：
- 召回模型：

#### 算法意义

- 语义理解：不同于传统的关键词匹配搜索，它会深入理解搜索查询（query）的语义含义。例如，当用户输入 “用户登录和密码加密” 时，工具不仅会识别 “登录”“密码” 等关键词，还会理解这些词汇组合所指向的 “用户身份验证流程中对密码的安全处理” 这一整体语义。
- 代码库索引：在使用前，工具会对指定目录（path）下的代码文件进行预处理和索引。这个过程会提取代码中的关键信息（如函数功能、变量用途、代码逻辑等），并将其转化为计算机可理解的语义向量。这些向量能够捕捉代码的深层含义和上下文关联。
- 语义匹配：当用户输入查询后，工具会将查询也转化为对应的语义向量，然后计算该向量与代码库中已索引的各个代码片段语义向量之间的相似度。相似度越高，说明该代码片段与查询的语义关联越紧密。
- 结果返回：根据相似度排序，工具会筛选出最相关的文件并返回给用户，帮助用户快速定位到与查询内容语义匹配的代码资源。
- 简单来说，codebase\_search 就像一个 “能理解代码含义的搜索引擎”，通过捕捉查询和代码的语义关联，精准找到用户需要的相关代码文件，尤其适合在大型代码库中快速定位特定功能或逻辑的代码。

#### 提示词

	相对于上一版本每次根据模型回答去检索代码块，这一版将改为工具调用方式，由大模型决定启动代码检索的时机和常见。避免上一版本过量调用，无效调用、错误调用等问题。

提示词结构总览

codebase\_search工具插件

<a id="_Toc14327"></a>### 应用场景

对本模块在客户处的应用场景进行分析。客户应用本模块解决什么问题，客户在哪些场合、有哪些方式来应用本模块，使用过程中有哪些操作，会发生哪些事件，需要得到什么处理结果？比如：在京东购书，主场景是用户登录app，搜索图书，下单，付款，快递上门。过程中可能发生登录失败，付款不成功，等各种各样的事件。

场景分析的目的是分析清楚模块运行过程中会发生什么事件，分析的结果用以评估各方案在实际运行过程中，能否正常应对这些事件，会不会发生问题。

可以采用用例分析（use case）方法对场景进行分析，也可以用事件流分析方法对场景进行分析，参考：[http://200\.200\.1\.35/designing/aim/scene\-analysis\.html](http://200.200.1.35/designing/aim/scene-analysis.html)。

#### RooCode典型常见示例

找到功能入口点（Find feature entry points）

查找业务逻辑 Find business logic

查找配置Find configuration

####  潜在功能场景

1\.功能相关场景

- 定位同类功能实现：当需要实现某个功能（如 “图片压缩”“数据导出为 Excel”）时，通过搜索可快速找到代码库中已有的类似功能实现，便于参考复用或统一逻辑。
- 查找功能扩展点：对于需要扩展的功能（如 “用户权限新增角色类型”），搜索能定位到与该功能相关的配置、接口或核心处理模块，明确扩展方向。

2\. 代码维护与优化场景

- 识别冗余代码：搜索与特定功能（如 “旧版支付接口处理”）相关的代码，可发现重复实现或已废弃但未删除的冗余代码，便于清理优化。
- 定位潜在 bug 关联点：当出现某类 bug（如 “订单状态更新异常”）时，搜索相关业务逻辑代码，能快速锁定可能存在问题的代码片段，辅助排查。

3\. 团队协作与知识传递场景

- 新成员快速熟悉代码：新成员可通过搜索 “用户注册流程”“订单生成逻辑” 等查询，快速找到核心代码位置，了解系统架构和业务实现。
- 文档与代码对齐校验：搜索文档中描述的功能（如 “API 接口限流机制”），对比找到的代码实现，确保文档与实际代码逻辑一致。

4\. 安全与合规场景

- 查找敏感操作实现：搜索 “数据库密码存储”“用户隐私数据处理” 等内容，可定位到涉及敏感信息的代码，检查是否符合安全规范（如加密存储、权限控制）。
- 合规性代码检查：针对特定合规要求（如 “GDPR 数据删除请求处理”），搜索相关代码，验证是否实现了必要的功能逻辑。

这些场景均依赖于工具对代码语义的精准理解，相比传统关键词搜索，能更高效地定位到与查询意图深层相关的代码资源，提升开发和维护效率。

<a id="_Toc13477"></a>### 对手分析

如果竞争对手有类似功能，本节对竞争对手的功能实现进行分析，说明对手的方案的优缺点，以及借鉴的地方。如果业界其它产品中有类似功能或方案，选择较为突出的进行分析，并说明借鉴的地方。对手分析的目的不是模仿对手，而是为了更全面的了解该领域需要面对的问题和前人已经使用过的解决方案，保证设计过程不要踩坑，做无用功。

#### continue

continue的上下文构建在用户本地，也就是客户端进行。流程如下所示：

1. 加载配置与项目元信息，遍历目录收集文件；
2. 初始化四类索引：代码切块、向量、全文检索、代码片段；
3. 代码文件用 Tree\-sitter 解析语法树，按函数 / 类切块，非代码按行切分；
4. 切块内容生成向量存入 LanceDB，同时构建全文索引和函数级片段索引；
5. 基于内容摘要实现增量更新，仅处理变更文件；
6. 多索引融合（语义 \+ 关键词 \+ 结构）提升检索效率；
7. 分层存储（SQLite\+LanceDB）平衡结构化数据与向量检索性能；
8. 智能匹配语言特性，适配多编程语言；
9. 最终提供函数级定位、语义搜索等上下文能力。

#### cursor


continue的上下文构建在服务端进行。

在 Cursor 的设置界面中，索引过程涉及创建嵌入（embeddings），即代码的向量表示，用于捕捉代码的含义和上下文。这些嵌入通过复杂的机器学习模型生成，并存储在云端。通过将嵌入存储在云端，Cursor 能够利用强大的计算资源进行分析，同时将实际代码安全地保存在开发者的本地机器上。这种设计在性能和数据隐私之间取得了平衡，这在软件开发中是一个关键考量。

Cursor 的索引不仅限于代码文件本身，还与我们的 Git 历史集成，以理解文件之间的关系以及代码库随时间演变的轨迹。通过分析提交历史，Cursor 可以识别哪些文件经常一起更改，理解特定代码变更的上下文，甚至根据最近的修改建议相关文件进行编辑。这种集成增强了 AI 提供上下文感知辅助的能力。

Cursor 提供了多种选项，让我们根据需求定制索引过程。例如，我们可以配置要忽略的文件或文件夹。这对于排除生成的文件、第三方库或其他与 AI 辅助不相关的代码库部分非常有用。通过将索引集中在项目的最重要部分，我们可以提升性能并减少不必要的处理。

原文链接：Cursor 中代码库索引（codebase indexing）功能背后的核心技术实现原理\_cursor indexing\-CSDN博客

Cursor 的代码库索引功能主要包括以下几个步骤：

- __文件扫描与预处理__

遍历整个项目目录，读取各个源代码文件，对文件内容进行必要的预处理（例如去除多余空白、统一编码格式等）。

- __文本分块（Chunking）__

将每个文件按一定规则拆分为若干“块”（例如按行数、字符数或语义段落切分），以确保每个块不会过长，同时又能保持完整的上下文信息。

- __生成向量嵌入（Embedding）__

利用预先训练好的嵌入模型（可能是专门针对代码进行微调的模型），将每个代码块转换为固定维度的向量表示。这一步是整个索引系统的核心，直接决定了后续语义匹配的效果。

- __构建向量索引库__

将所有代码块的嵌入向量与相应的元数据（如文件名、位置等）存储到一个高效的向量数据库或内存索引中，常用的实现方式包括 FAISS、Annoy 等近似最近邻搜索库。

- __查询时的检索与排序__

当用户提出查询时，将查询文本同样经过嵌入模型转换为向量，然后在向量索引库中执行近似最近邻搜索，获取与查询语义最接近的代码块，并根据相似度分数进行排序。

- __结果整合与反馈__

将检索到的代码块作为附加上下文传递给语言模型，以便在生成代码建议、回答问题或执行其他操作时提供更丰富的背景信息。

- __实时更新与缓存管理__

当代码库发生修改（新增、删除或更新文件）时，需要及时重新计算对应文件的嵌入，并更新向量索引，保证索引库与实际代码保持一致。同时，为了保证响应速度，还需要设计缓存策略来减少重复计算。

<a id="_Toc32287"></a>## 方案选型

*此章节，需要使用方案选型表对核心需求项的多个可行方案进行选型，确定最终采用的实现方案。*

*此处简述本设计的可供选型方案，并说明最终所选的方案，以及选择该方案的原因。*__*此章节需最先完成，并且方案选型表讨论通过，才能展开下一步的设计工作。参考：*__[http://200\.200\.1\.35/designing/decision/scheme\_select\.html](http://200.200.1.35/designing/decision/scheme_select.html)

*说明：*

*1、合理的方式，应该是如下用打分的方式进行判断*

*2、如果打分有困难，至少应该填写黄底色框，并叙述最终所选择方案的优点、风险和缺点，目的是只有考虑周全的方案才是合理的，凭借个人经验、对评估准则个人有个人看法的，所选择的方案有可能存在重大风险，埋下地雷。*

#### 4\.2\.1 向量数据库

主流向量数据库对比

__产品__

__优势__

__局限__

__推荐场景__

__Milvus__

1. 分布式架构，支持百亿级向量规模，适合超大规模代码库 
2. 支持混合查询（向量 \+ 标量） 

3\. 中文社区活跃，文档完善

1. 架构复杂，运维成本较高

2\. 语义推理需自定义实现

企业级代码仓库、开源代码检索平台

__Qdrant__

1. 轻量级部署，内存占用低（适合边缘计算或中小规模代码库） 
2. 支持动态向量维度调整 

3\. 实时增量更新，无需重建索引

1. 分布式集群功能需商业版；

 2\. 复杂查询性能较弱

中小型代码团队、IDE 插件

__Weaviate__

1. 原生支持向量 \+ 图数据库，适合构建代码知识图谱 ；
2. 内置大模型集成（如 OpenAI），支持自动向量化 ；
3. 多模态检索；

1. 纯向量检索性能不如 Milvus ；
2. 商业版按节点收费，长期成本较高
3. 没有图形客户端

代码语义分析、跨语言代码检索

最终选择：__Weaviate__

原因： 部署运维简单，支持多副本扩展，同时支持向量和图结构存储。支持图向量检索，精度高

#### 4\.2\.2 代码文本切块

__方案类型__

__切块策略__

__优点__

__缺点__

__适用场景__

__技术实现要点__

__基于行号__

固定行数切块（如每 50 行一块）

实现简单，易于理解和调试；支持随机访问；适合快速原型。

可能导致语义不完整（如函数被截断）；块大小与代码复杂度不匹配。

代码结构相对简单、函数短小的项目；快速验证向量嵌入效果。

按行读取文件，使用计数器分割；记录起始行号用于后续定位。

__基于函数 / 类（Tree\-sitter）__

按代码元素（函数、类）切块

语义完整性强，保留完整逻辑单元；适合函数调用分析、代码补全。

需依赖编程语言解析器（如 AST）；不同语言解析逻辑复杂。

面向对象语言（如 Java、Python）；需要保留完整方法 / 类结构的场景。

使用语言解析器提取函数 / 类定义；处理嵌套结构（如内部类）。

__基于 AST 节点__

根据抽象语法树（AST）结构切块（如函数体、类定义）

精准保留代码逻辑结构；与代码分析工具（如 IDE）深度集成。

需要完整解析代码，性能开销大；不同语言 AST 结构差异大。

静态代码分析、代码重构建议；需要精确理解代码逻辑的场景。

使用语言特定的解析器（如 Python 的ast模块、Java 的 ANTLR）；处理语法糖和特殊语法结构。

__混合策略__

结合行号和语义（如每 100 行或遇到函数结束符时切块）

平衡效率和语义完整性；适应性强。

规则复杂，调试和维护成本高；可能需要多次遍历代码。

代码风格差异大、结构复杂的项目；通用型代码分析工具。

定义优先级规则（如先按函数，再按行号）；使用状态机处理边界情况。

__滑动窗口__

固定大小窗口，重叠率 50%（如每 100 行，窗口移动步长 50 行）

保留上下文连续性；减少语义断裂风险。

数据冗余增加；向量计算量翻倍；需要额外处理重叠部分。

长序列依赖强的场景（如代码生成、跨函数推理）。

生成块索引映射表；在检索时合并重叠部分的结果。

__基于依赖分析__

根据函数调用关系或变量引用关系切块（如将相互调用的函数放在同一块）

保留代码运行时的逻辑关联；提升上下文相关查询的准确性。

需要构建完整的代码依赖图，计算开销大；难以处理循环依赖。

微服务架构、模块化设计的项目；需要分析代码调用链的场景。

使用静态分析工具（如 Go 的go/ast、Java 的 Soot）构建调用图；应用图分割算法。

__基于 Token 数量__

按 Token 数切块（如每 512 个 Token 一块）

适配向量模型输入限制（如 OpenAI 的 token 上限）；确保块大小均匀。

可能截断函数或表达式；需要额外的 Tokenizer；不同语言 Token 密度差异大。

直接使用预训练模型（如 CodeBERT）的场景；需要严格控制输入长度的模型。

使用与模型匹配的 Tokenizer（如 GPT 的 BPE）；处理特殊符号（如注释、字符串）。

__最终选择：__混合策略（基于函数 / 类Tree\-sittter \+ 滑动窗口） 

策略组合

1. 优先按函数 / 类切块：将完整的函数、类定义作为基础切块单元，保证语法有效性
2. 对超长单元应用滑动窗口：对超过模型输入限制的函数，使用带重叠的滑动窗口进一步拆分
3. 保留元数据关联：记录每个切块对应的文件路径、起始行号、父函数 / 类信息

核心优势

1. 语义完整性
	1. 保留代码的自然逻辑边界（函数 / 类），避免语义碎片化
	2. 适合捕捉代码元素间的关系（如函数调用、类继承）
2. 模型适配性
	1. 通过滑动窗口控制块大小，适配向量模型的输入限制（通常≤2048 tokens）
	2. 重叠设计确保关键上下文不丢失（如函数参数定义与实现逻辑）
3. 泛用性与扩展性
	1. 支持多种编程语言（通过 AST 解析器适配）
4. 工程可行性
	1. 实现复杂度可控（现代编程语言均有成熟的 AST 解析库）
	2. 支持增量更新（仅重新处理变更的文件）   关系/语义都可以使用增量更新，仅更新变更的文件。

#### 4\.2\.3 调用链解析

__方案类型__

__技术栈__

__优点__

__缺点__

__适用场景__

__实施难度__

__自研 Tree\-sitter 解析器__

Tree\-sitter

完全自定义，支持多语言，灵活扩展；避免依赖第三方格式

开发成本高，需维护多种语言的解析逻辑；性能优化难度大

需深度定制关系解析逻辑；支持小众或自研语言

★★★★☆

__直接使用 SCIP 格式__

Sourcegraph SCIP

标准化格式，支持多语言；Sourcegraph 生态支持良好

依赖第三方工具链；对复杂场景支持有限；需学习新格式规范

快速集成现有代码索引；与 Sourcegraph 生态深度集成

★★☆☆☆

__SCIP 与 Tree\-sitter 结合__

SCIP \+ Tree\-sitter

结合两者优势，覆盖更多场景；标准化与灵活性并存

架构复杂度高；需解决数据融合问题

需支持复杂场景（如宏、动态语言）；对性能和准确性要求高

★★★★☆

__最终选择： SCIP   \+ Tree\-sitter 混合方案。  __

SCIP介绍：

SCIP（Source Code Intelligence Protocol）是由 Sourcegraph 开发的一种标准化格式，用于表示代码仓库中的符号信息和关系，支持跨语言的代码智能分析。它为代码编辑器、IDE 和代码搜索工具提供了统一的接口，使开发者能够更高效地理解和导航大型代码库。

一、核心特性

1\. 标准化格式

语言无关：支持多种编程语言（Java、TypeScript、Go、Python 等）

符号表示：统一表示函数、类、变量等代码元素

关系建模：定义调用、继承、实现、引用等关系类型

2\. 增量更新

支持部分代码更新的增量索引，无需全量重建

适用于持续集成 / 持续部署（CI/CD）流程

3\. 高效存储与查询

使用 Protocol Buffers 序列化，压缩率高

支持快速符号定位和关系查询

4\. 生态兼容性

与 Sourcegraph 平台深度集成

支持导入到其他工具（如 VS Code、JetBrains IDE）

二、数据模型

SCIP 主要包含以下核心概念：

1\. 符号（Symbols）

唯一标识代码元素（如 com\.example\.UserService\#findById）

支持命名空间、泛型等复杂结构

2\. 文档（Documents）

表示单个文件的符号信息

包含文件路径、语言、符号定义和引用位置

3\. 关系（Relationships）

定义（Definition）：符号的声明位置

引用（Reference）：符号在其他地方的使用

调用（Call）：函数调用关系

继承 / 实现（Inheritance/Implementation）：类 / 接口关系

4\. 包和依赖

记录代码库的依赖结构

支持跨项目的符号解析

三、工作流程

索引生成：

使用语言特定的 SCIP 索引器（如 scip\-java、scip\-typescript）分析代码库

生成 \.scip 文件，包含符号和关系信息      \# 非编译语言，需要先编译。（需要明确是否需要先编译才能使用）

索引导入：

将 \.scip 文件导入到 Sourcegraph 或其他支持 SCIP 的工具

工具解析 SCIP 数据，构建符号索引

查询与应用：

通过 API 查询符号定义、引用和关系

在编辑器中实现代码跳转、自动补全、调用链分析等功能。

下图是sourcegraph 公司款开源的代码搜索平台，支持代码的定义、引用等查看，其中用到的技术就是scip：


scip 支持的编程语言：


#### 4\.2\.4 RAG 框架选型

__框架 / 库__

__类型__

__优势__

__劣势__

__适用场景__

__集成难度__

__langchaingo__

全功能 RAG 框架

\- 完整 RAG 流程支持（文档加载、分块、嵌入、检索、提示组装）

\- 与 Weaviate 官方集成

\- 支持多种 LLM 提供商（OpenAI、Hugging Face 等）

\- 功能丰富导致学习曲线较陡

\- 部分高级功能依赖 JavaScript 实现

快速构建端到端 RAG 系统，需要完整工具链支持

★★★☆☆

__weaviate\-go\-client__

向量数据库客户端

\- Weaviate 官方 Golang 客户端

\- 完整支持 Weaviate API（CRUD、向量搜索、聚合）

\- 高性能、类型安全

\- 仅专注于 Weaviate 交互，需自行构建 RAG 其他组件

\- 无 LLM 集成

已熟悉 RAG 流程，需要直接控制 Weaviate 操作

★★☆☆☆

__最终选择__： langchaingo。

原因：已定义好相关RAG和大模型调用接口，同时支持多种向量库，开箱即用，可扩展性好。

<a id="_Toc723"></a>## 静态结构

本章节描述模块中各软件单元（子模块或类）之间的结构关系，使用静态视图方式描述（比如类图、结构图等）。即整个模块可以分解为哪些软件单元，这些软件单元相互之间是什么关系，以及他们是怎么协作完成整体工作任务的。

本章节还需描述那些作为流程间协作纽带的公共数据结构，比如连接跟踪模块的连接表。本章对数据结构进行概要描述，主要描述数据结构设计意图以及与其它数据结构之间的关系，帮助理解围绕该数据结构设计的概要流程。详细定义可以放在后续章节给出。


                                                                                             上下文模块内部静态结构图

- 模块内部分层、分子模块
- 提供存储接口层，屏蔽底层存储细节，便于扩展。 
- 后面可考虑统一的缓存的管理，加快查询，淘汰机制。

<a id="_Toc12861"></a>## 对软件总体架构的影响

本章节描述本次新增及调整模块对软件总体架构的影响点。

情况分类

是否对总设有影响

1 本次新增或调整的模块对总体架构是否有影响

*否*

2 本次新增或调整的模块对总体架构有一定程度的影响，但涉及的模块少于3个（如调整了某个基础模块对外提供服务的方式，由socket通信改为了rpc调用），请在本章节描述具体的架构改动内容；

*否*

3 本次新增或调整的模块对总体架构有较大影响，需要对原有软件架构进行较大调整或者重新设计，请重新做设计策略。《XXX版本设计策略说明书\.docx》模板：

https://cms\.atrust\.sangfor\.com/pages/viewpage\.action?pageId=46981063

*否*

<a id="_Toc2205"></a>## 概要流程

说明本模块的基本设计概念和处理流程动态视图，尽量使用图表的形式，并描述其具体步骤。本节描述的流程一般是那些涉及到多个子模块\(或类\)的流程。

### 向量构建概要流程

代码文件转换为向量的概要流程。

													向量构建流程图

									向量构建流程图（旧）同步文件服务已拆分

需要维护文件列表，哪些被更新，做到断点构建。

### 向量检索概要流程

向量检索的流程。

							                                               向量检索流程图（旧）

### 向量检索清理流程

                                                                   
定时任务每日扫描pgsql、weaviate存储状态，如接近满则清理最近不活跃的一批工程。

### 可调试性机制分析及设计

分析本模块中哪些业务流程是调试难度较高的流程（比如依赖高并发、大流量、海量数据的流程，比如依赖条件复杂或者苛刻，很难跑到的流程，比如很难分析结果正确性的流程，等等），给出具体调试方法（比如录制数据重放以重现错误，比如利用调试接口诊断某类错误），和降低调试难度的方法（比如记录内部状态，定时进行数据有效性自检，添加校验值自动校验数据正确性，增加调试接口等等）。

分析本模块在客户场景可能出现的故障，给出供技术支持人员诊断错误的方法和工具。

      （1）所有请求携带 x\-trace\-id， 便于分布式链路追踪；

      （2）关键处理逻辑，增加日志打印；

      （3）构建异步任务，增加开关，增加接口，可手动触发； 

      （4）提供工具，可以查看结果是否正确；比如提供接口，检查数据是否完整，形成目录tree，更新时间等，判断是否构建正确。

<a id="_Toc3498"></a>### 可测试性机制分析及设计

1. 分析本模块中哪些业务流程是测试难度较高（比如逻辑复杂，容易测试不完全），或者依赖性较高（依赖环境或依赖其它模块，比如依赖特殊硬件，特殊内核版本，比如依赖北研数据面）；
2. 对测试难度较高的业务流程给出测试方案，对依赖性较高的业务流程给出解耦方法；
3. 给出降低测试复杂度的方法，包括测试方法的改进，以及对本模块设计方面的改进；

可测试性机制设计的目的是降低后续测试的难度，提高测试工作效率和质量，尽早发现问题。为了提升可测试性设计的质量，设计者需要遵守《软件可测试性技术规范》的要求，详情请参考：http://docs\.sangfor\.org/pages/viewpage\.action?pageId=42148775

       （1）进行80%单元测试覆盖。

        （2）数据库、向量库提供mock机制。

<a id="_Toc11261"></a>### 可扩展可复用设计

分析本模块后续可能的扩展要求，以及可供后续扩展使用或其它模块使用的流程机制；

（1）代码库关系图结构存储，当前考虑开发维护成本，先存储于关系型数据库中，后续考虑是否切换为图数据库。提供接口和配置以支持扩展；

（2）源码仓库文件的存储，考虑开发维护成本，先存储于NFS中，提供接口和配置，可扩展为 minio、git远程仓库等。

 （3）抽象接口， 后面考虑分布式存储。

<a id="_Toc19695"></a>### 系统隐私设计

隐私目标：定义系统不会出现因自身安全而造成敏感信息泄露的目标：系统在收集用户信息时，不会出现私自收集用户不清楚及用户不同意收集的数据；

隐私设计：给出系统在业务传输过程保护方面的设计机制，包含但不限于各类业务的传输敏感信息时，需要使用安全协议传输，以及对内容进行加密传输；此外需要确保系统在收集信息时，应明确为什么需要收集该信息，还应尝试预判未来是否会使用这些信息用于其他事物，并告知用户是否有这样的计划，提供一份易于阅读的条款或条件的摘要。

        （1）按用户隔离代码仓库及上下文，避免检索到他人的代码仓库信息。

<a id="_Toc25712"></a><a id="_Toc23875"></a>### 安全性设计

<a id="_Toc18113"></a>#### __4\.5\.7\.1 威胁建模分析（由产线安全经理判断是否需要执行）__

威胁建模分析，目的是分析该版本总体设计中涉及到的各个模块实体、数据存储、进程服务、开放端口、交互协议等是否存在相关的安全威胁风险，把风险识别出来并填入如下表格，

威胁建模分析报告模板：http://docs\.sangfor\.org/pages/viewpage\.action?pageId=125271763（序号02）

<a id="_Toc29997"></a>#### __4\.5\.7\.2 安全设计__

*根据上一节威胁建模识别出来的风险和建议采取的安全措施，各个模块威胁对应的安全机制，在此章节进行详细描述，比如通信协议要加密，就需要设计相关的加密方案。*

##### __4\.5\.7\.2\.1模块1安全设计__

*详细描述模块1的安全设计机制。*

         （1）所有请求都需要经过网关认证，通过https加密；

          （2）容器禁止privillege=true，避免影响宿主机；  

          （3）数据库等密码进行加密；        

           （4）  避免抓包，api网关做防重放攻击。

<a id="_Toc14914"></a>#### __4\.5\.7\.3 预使用组件版本合规性及版本漏洞情况（必做）__

*使用开源组件扫描器对预计使用的组件版本进行合规性扫描（   网址及使用方式，请与产线安全经理联系）有严重、高危必须修复，扫描完即可*

     使用到的开源组件：weaviate、scip、go\-storage、langchaingo

### 资源需求设计

指标

当前预估值，实际根据后续测试

实际

CPU

8核

内存

8G

网络

1M

显卡

rtx4080\*8

### 性能设计（在标定资源情况）

指标

说明

当前预估值

实际

同时处理用户数

此用户该段时间不间断触发（压测）

20

整体入库速度

每秒钟能调试、还需测试是否是线性关系

10000字符串/每秒  （多用户需均摊速度）

成功率

以单个文件计算：  
成功文件/文件总数

90%

检索速度（接口端对端）

包含网络传输、embbedding，检索，rerank，预处理和后处理等时间。  


平均1s内

<a id="_Toc24060"></a>### 可靠性设计

*分析本模块的每个功能流程运行过程中会出现哪些故障场景（包括在模块流程内部产生的故\-\-\-例如文件读写失败，以及本模块和其他模块交互时其他模块传递过来或者表现出来的故\-\-\-例如传递错误的数据或者消息、无响应、超时响应、响应慢），这些故障场景触发的原因以及对本模块流程的影响（中断、卡慢、输出数据错误等等），给出故障容错方案（故障检测方案、故障恢复方案）以避免造成本模块业务流程的失效（中断、卡慢、输出数据错误等等），对于无法自动容错（比如硬盘坏了导致进程无法启动等等）的故障场景需要给出人工介入的处理指导（人工如何感知故障，如何进行恢复）*

*此处的故障场景分析建议覆盖模块内的每一个流程，底线必须要覆盖主要（核心）流程，对于简单（体量小，逻辑简单等）的模块特性，直接给出上述内容，但是对于复杂（体量大，逻辑复杂等）的模块特性，需要采用正式的FMEA分析方法进行，输出FMEA分析报告。*

*FMEA分析模板：http://docs\.sangfor\.org/display/ReliabilityWorkGroup/01\+SFMEA*

1. *画出每个流程的流程图，参照如下的截图进行*

1. *给出每个流程的故障场景、故障原因、故障检测、恢复方案*

*做FMEA分析的，直接将分析报告附在此处*

*[https://docs\.atrust\.sangfor\.com/pages/viewpage\.action?pageId=212302936](https://docs.atrust.sangfor.com/pages/viewpage.action?pageId=212302936) FMEA分析模板*

*故障检测与故障恢复的具体要求，请参照《深信服可靠性需求基线》，《深信服可靠性设计准则库》进行。*

*[http://docs\.sangfor\.org/pages/viewpage\.action?pageId=167438827](http://docs.sangfor.org/pages/viewpage.action?pageId=167438827)   设计准则库*

*[http://docs\.sangfor\.org/pages/viewpage\.action?pageId=122772969](http://docs.sangfor.org/pages/viewpage.action?pageId=122772969)   可靠性需求基线*

*[https://docs\.atrust\.sangfor\.com/pages/viewpage\.action?pageId=183931987](https://docs.atrust.sangfor.com/pages/viewpage.action?pageId=183931987)  不贰过设计准则*

1. *需要邀请版本可靠性SE进行评审，评审通过后方可进入下一步，如果没有版本可靠性SE，直接邀请工技术部/可靠性能力部可靠性专家进行评审（notes邮件RELG）*

异常场景分析及解决方案：

（1）代码仓库文件过大、过多，导致处理很久：设置单个代码仓库文件数量处理的阈值，单个文件大小的处理阈值，超过阈值则不处理，同时记录异常信息；

（2）代码文件解析失败； 记录异常信息，进行重试，重试依旧失败，记录任务标记任务为失败；

（3）向量模型无法访问；重试N次，标记任务为失败，并记录异常信息；

（4）数据库无法访问；重试N次，标记任务为失败，并记录异常信息；

（5）向量库无法访问；重试N次，标记任务为失败，并记录异常信息；

（5）存储无法访问；重试N次，标记任务为失败，并记录异常信息；

（6）检索时间过久；设置超时时间，超时则报错；

 （8） 并发过多，比如100，采取限流·、排队，拒绝策略；数据过多时，比如500GB，支持基于LRU的淘汰机制。

各类异常情况处理方法:

异常情况

解决机制

大量用户同时提取向量导进度缓慢

一般是资源不足情况，通过令牌机制，保障部分用户正常提取，其余用户排队，并显示正在处理任务数

部分大工程用户占用向量库提取，导致文件很小的用户得不到处理

内部建立多队列排队机制，通过文件总数来预测排哪一个队列

embbedding和rerank部分不可用

通过重试N次提高稳定性，同时模型侧做好负载均衡

embbedding和rerank全部不可用

正确返回错误码，打印关键日志并警报，并屏蔽此功能

数据库、redis、weaviate断联

正确返回错误码，打印关键日志并警报，并屏蔽此功能

本服务挂掉

重新拉起，并协同上下游做出功能屏蔽,并友好显示给用户

<a id="_Toc25890"></a>### 可维护设计

说明为了系统维护的方便而在程序内部设计中作出的安排，包括在程序中专门安排用于系统的检查与维护的检测点和专用模块。

      （1）整体架构及模块设计尽量简单，模块间耦合较多的直接合并为一个模块，避免拆分过细，减少微服务调用，避免网络通信等原因引起的出错；

      （2）尽量复用已有的组件，减少第三方组件的引入，降低运维成本。

<a id="_Toc6254"></a>### 跨平台设计和平台差异处理

*该模块目前及以后可能运行在哪些平台上，如x86，ARM，MIPS等，32位系统还是64位系统，在差异处理上做统一的规范约定。如果对未来的规划不清楚，尽可能设计成跨平台的。跨平台是整个设计过程都要去考虑的事情，包括对外接口设计，数据结构定义，流程设计，函数详细设计等。*

*请在这里描述一下该模块跨平台时有哪些地方需要注意，比如对外通讯接口是否平台无关，数据结构的设计是否能适应32位和64位系统变迁，是否能自适应大小端。这里设计的目的是要用统一的一套代码完成需求，而不要维护多套代码。可以像linux内核那样，把平台无关的流程提炼成公共文件，平台相关的代码写到不同的文件。*

      该模块以容器形式运行在Linux服务端，没有跨平台的需求。

<a id="_Toc13894"></a>## 方案风险分析

*对本章描述的方案进行整体风险分析，找到所有可能存在风险的关键环节，对每一个风险，需要给出解决方法（包括消除、规避、缓解、后续跟进等）。对于现阶段无法消除的风险，需要整理为列表，作为后续跟进的事项。*

对于有风险没有把握的设计，需要有预研结果做保证或者有备用方案。万一此路不通，可以选择备用方案。

风险点

风险预研结果/风险规避措施

1. 使用scip进行代码图谱解析的准确性？
2. 解析编译型语言时，是否要先编译才能进行解析？

1. scip作为sourcegraph开源的代码导航协议，在本地运行源代码继续测试，验证typescript、go、python、java等语言，基本都能将项目内的依赖关系解析成功，准确性较高。
2. 否。不需要编译项目，即使项目代码语法有问题，也能解析成功。 但是，它存在一定的性能问题。因为它需要构建项目的依赖，scip 不光解析项目源文件之间的关系，还会解析它的第三方依赖。 比如对于c项目，它需要通过  cmake \-B build \-DCMAKE\_EXPORT\_COMPILE\_COMMANDS=ON  命令输出编译编译指令到 compile\_commands\.json 文件中。 由于存在构建依赖的过程，这也导致对于大型项目，耗时在1分钟以上，同时，它不支持增量构建依赖关系，每次都是全量。解决办法：（1）并行构建，通过增大资源，来缩短时间；（2）使用tree\-sitter 作为增量构建的后手。

<a id="_Toc16312"></a># 数据结构设计

<a id="_Toc7141"></a>## 配置文件定义

*定义相应的配置文件格式，存储方式，存储路径，各字段代表什么意义。如果是存储在数据库中，需说明数据库名，表名。*

*如果需要在原有配置文件基础上升级，需描述配置的升级流程。*

## 全局数据结构定义

*描述全局数据结构设计，须描述每一个字段的名称和作用。全局数据结构包括：*

1. *在多个软件单元之间传递（比如通过函数参数）的数据结构；*
2. *全局变量；*
3. *通讯用的消息；*

<a id="_Toc14114"></a># 流程设计

描述模块内部各软件单元的组织结构，接口，以及逻辑，算法实现等。这里指的软件单元可以是一个子模块，也可以是C\+\+的一个类。

## 向量构建子模块

<a id="_Toc12451"></a>### 静态结构

描述本子模块的职责定义，以及本子模块由哪些更细化的软件单元组成。


<a id="_Toc25519"></a>### 处理流程

描述子模块内部各函数之间的交互逻辑。

<a id="_Toc1972"></a>### 关键算法描述

分析本子模块中哪些算法流程是关键流程，会影响到模块整体的关键性能。有性能（或效果）要求的算法必须在此阐述。每个算法须描述最常见的场景及性能最差的场景，并说明在这两个场景下可达到的性能指标。如果最差场景不能达到性能要求，需分析该场景在用户处出现的几率，以及出现该场景对用户造成的负面影响。

       代码切块算法： 基于Tree\-sitter 解析形成语法树，按函数进行切块，对于没有函数的类或结构体，则分为一块，对于太长的块，设置一个长度阈值，比如100，通过滑动窗口，保留一定的overlap\(比如20行\)。

### 异常重试机制

特征提取重试和超时:考虑到网络以及模型稳定性原因，构建过程中进行超时时间（5s）和有限次数重试\(3次\)。

<a id="_Toc31835"></a>### 数据结构定义

描述函数间传递的数据结构或者进程/实体间传递的消息。

<a id="_Toc29615"></a>### 函数列表

描述本模块中需要实现的函数。对于每个函数，需要描述函数的名字，函数功能，参数的类型和作用、取值范围，返回值的类型和作用、取值范围，以及该函数的其它前后置约束条件（比如需要访问的全局变量）。

__函数名__

__函数功能__

__参数及返回值__

__说明（包括其它前置/后置约束条件，等）__

*generate*

*生成测试案例*

*\[in\]const value\_t\* val：输入模板，必须为有效的value\_t；*

*\[out\]vector<value\_t\*>\* ptests：保存输出的案例，调用者负责释放。约束条件：ptests && ptests\->size\(\) == 0*

<a id="_Toc26500"></a>### 设计要点检视

本表格作为一个设计要点的检查列表，帮助设计人员回顾相关要点具体是怎么考虑的，是否已经满足需要。相关要点必须体现在本章的各个子章节中（比如结构、流程、函数列表等），表格填写内容仅仅作为一个总结。

__可维护/可调试措施__

*分析开发过程可能遇到的调试难题，描述设计中所提供的解决方案。需要说明针对这些调试难题，给开发调试、维护人员具体提供了哪些排错手段。怎么帮助开发、维护人员更快定位，排除错误。*

__可测试性__

*分析测试过程可能遇到的测试难题，描述设计中所提供的解决方案。需要说明针对这些测试难题，给测试人员提供了哪些测试支持。怎么保证更易于测试本模块。*

__自动化测试支持__

*分析该子模块如何进行自动化测试，怎么保证自动化测试能够更好验证本子模块/类的功能。*

__可扩展性__

*分析将来版本最有可能发生扩展的特性，说明针对这些扩展保留的设计支持；*

__稳定性保证措施__

*分析软件运行过程中，该子模块容易发生哪些类型异常，给出异常检测，异常恢复措施*

__工作量估算__

*对实现本节设计内容需要的工作量进行估算，按人天算。设计需要消除风险，让风险可控。风险可控的典型标志就是可以较为准确的估算出工作量*

## 6\.3\. 向量检索子模块

#### 处理流程


#### 关键算法描述

预处理:

query清洗:通过截断、去除多余字符、清洗特殊字符方法。避免超长、无异议字符。

query改写：使用户问题更接近代码库向量

\.\.\.

后处理：

特征验证：通过特征相关性验证获取代码特征二次验证

代码扩增：embbedding上下文优先，必要的情况进行上下扩增。

\.\.\.

当前转为工具方式调用，可以达到互补。

时延

#### 异常处理

特征提取和重排重试和超时:考虑到网络以及模型稳定性原因，构建过程中进行超时时间（5s）和有限次数重试\(3次\)。

<a id="_Toc2606"></a># 总结

<a id="_Toc9880"></a>## 关联分析

对老模板/老版本/相关联产品的影响，请做分析。可以和对应的模块责任人架构师做交流

       新模块，对老模块无影响。

<a id="_Toc16104"></a>## 遗留问题解决

说明在总体设计过程中尚未解决的各个问题的解决方案。

说明在上一个版本未解决的应该在本模块中解决的各个遗留问题的解决方案；

     新模块，无上个版本遗留问题。

<a id="_Toc19260"></a><a id="_Toc318988337"></a># 业务逻辑相关的测试用例

此部分内容在详细设计模板中也有。如果一个模块概设、详设都做，此章节在其中一个文档中完成即可。

设计完成后，鉴于测试人员可能对模块设计的内部逻辑、流程、数据流向不清楚，用例质量会得不到保证。

为了提高测试用例的质量，尽早尽全地覆盖到关键实现，要求开发人员撰写内部逻辑、流程、数据流向相关的测试用例。 

如果对测试用例的设计不太清楚，至少要描述出测试步骤和验证点。

此部分可以放到编码结束后补充填写。 

如果给测试人员讲的很清楚，测试版本经理认为不用写，可以不写。 

    没有专职测试人员和测试版本经理，通过开发进行单元测试和自测。

<a id="_Toc3237"></a># 变更控制

<a id="_Toc8875"></a>## 变更列表

*在编码过程中，可能会有一些设计不合理的地方，需要对原设计做一些调整，需要在这里说明变更的章节、内容、原因，并对变更进行评审确认（至少需要经过版本经理/开发经理的确认）。此章节在编码完对设计文档更新后进行评审确认。*

*需求变更引起的设计变更，也在下面加以说明，并对设计变更的结果进行部门内部评审。*

__变更章节__

__变更内容__

__变更原因__

__变更对对老功能、原有设计的影响__

考虑完全这些影响，要和开发经理、架构师、设计人员、老版本的开发人员进行交流，并最后评审。

