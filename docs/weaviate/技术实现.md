# Weaviate 技术实现文档

## 核心组件分析

### weaviateWrapper 结构体

```go
type weaviateWrapper struct {
    reranker      Reranker          // 重排序器
    embedder      Embedder          // 嵌入模型
    client        *goweaviate.Client // Weaviate客户端
    className     string           // 类名
    cfg           config.VectorStoreConf // 配置
    statusManager *redis.StatusManager // 状态管理器
    requestId     string           // 请求ID
}
```

### 初始化流程

#### 1. 客户端创建

```go
func New(cfg config.VectorStoreConf, embedder Embedder, reranker Reranker) (Store, error) {
    var authConf auth.Config
    if cfg.Weaviate.APIKey != types.EmptyString {
        authConf = auth.ApiKey{Value: cfg.Weaviate.APIKey}
    }
    
    client, err := goweaviate.NewClient(goweaviate.Config{
        Host:       cfg.Weaviate.Endpoint,
        Scheme:     schemeHttp,
        AuthConfig: authConf,
        Timeout:    cfg.Weaviate.Timeout,
    })
    
    if err != nil {
        return nil, fmt.Errorf("failed to create Weaviate client: %w", err)
    }
    
    // 创建存储实例并初始化类
    store := &weaviateWrapper{
        client:    client,
        className: cfg.Weaviate.ClassName,
        embedder:  embedder,
        reranker:  reranker,
        cfg:       cfg,
    }
    
    // 初始化类结构
    err = store.createClassWithAutoTenantEnabled(client)
    if err != nil {
        return nil, fmt.Errorf("failed to create class: %w", err)
    }
    
    return store, nil
}
```

#### 2. 类创建与多租户配置

```go
func (r *weaviateWrapper) createClassWithAutoTenantEnabled(client *goweaviate.Client) error {
    // 检查类是否已存在
    res, err := client.Schema().ClassExistenceChecker().WithClassName(r.className).Do(timeout)
    if err == nil && res {
        return nil // 类已存在
    }
    
    // 配置动态向量索引
    dynamicConf := dynamic.NewDefaultUserConfig()
    class := &models.Class{
        Class:      r.className,
        Properties: classProperties,
        // 启用多租户和自动租户创建
        MultiTenancyConfig: &models.MultiTenancyConfig{
            Enabled:            true,
            AutoTenantCreation: true,
        },
        VectorIndexType:   dynamicConf.IndexType(),
        VectorIndexConfig: dynamicConf,
    }
    
    // 创建类
    err = client.Schema().ClassCreator().WithClass(class).Do(timeout)
    return err
}
```

## 关键操作实现

### 1. 代码块插入操作

```go
func (r *weaviateWrapper) InsertCodeChunks(ctx context.Context, docs []*types.CodeChunk, options Options) error {
    if len(docs) == 0 {
        return nil
    }
    
    // 生成租户名称
    tenantName, err := r.generateTenantName(docs[0].CodebasePath)
    if err != nil {
        return err
    }
    
    // 使用状态管理器或默认embedder生成嵌入向量
    var chunks []*CodeChunkEmbedding
    if r.statusManager != nil && options.RequestId != "" {
        embedderWithStatus, err := NewEmbedderWithStatusManager(r.cfg.Embedder, r.statusManager, options.RequestId, options.TotalFiles)
        if err != nil {
            return fmt.Errorf("failed to create embedder with status manager: %w", err)
        }
        chunks, err = embedderWithStatus.EmbedCodeChunks(ctx, docs)
    } else {
        chunks, err = r.embedder.EmbedCodeChunks(ctx, docs)
    }
    
    if err != nil {
        return err
    }
    
    // 构建Weaviate对象
    objs := make([]*models.Object, len(chunks))
    for i, c := range chunks {
        // 验证必要字段
        if c.FilePath == types.EmptyString || c.CodebaseId == 0 || c.CodebasePath == types.EmptyString {
            return fmt.Errorf("invalid chunk to write: required fields: CodebaseId, CodebasePath, FilePaths")
        }
        
        objs[i] = &models.Object{
            ID:     strfmt.UUID(uuid.New().String()),
            Class:  r.className,
            Tenant: tenantName,
            Vector: c.Embedding,
            Properties: map[string]any{
                MetadataFilePath:     c.FilePath,
                MetadataLanguage:     c.Language,
                MetadataCodebaseId:   c.CodebaseId,
                MetadataCodebasePath: c.CodebasePath,
                MetadataCodebaseName: c.CodebaseName,
                MetadataSyncId:       options.SyncId,
                MetadataRange:        c.Range,
                MetadataTokenCount:   c.TokenCount,
                Content:              string(c.Content),
            },
        }
    }
    
    // 批量插入
    resp, err := r.client.Batch().ObjectsBatcher().WithObjects(objs...).Do(ctx)
    if err != nil {
        return fmt.Errorf("failed to send batch to Weaviate: %w", err)
    }
    
    // 检查批量操作错误
    if err = CheckBatchErrors(resp); err != nil {
        return fmt.Errorf("failed to send batch to Weaviate: %w", err)
    }
    
    return nil
}
```

### 2. 相似性搜索实现

```go
func (r *weaviateWrapper) SimilaritySearch(ctx context.Context, query string, numDocuments int, options Options) ([]*types.SemanticFileItem, error) {
    // 生成查询向量
    embedQuery, err := r.embedder.EmbedQuery(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("failed to embed query: %w", err)
    }
    
    // 生成租户名称
    tenantName, err := r.generateTenantName(options.CodebasePath)
    if err != nil {
        return nil, fmt.Errorf("failed to generate tenant name: %w", err)
    }
    
    // 定义GraphQL查询字段
    fields := []graphql.Field{
        {Name: MetadataCodebaseId},
        {Name: MetadataCodebaseName},
        {Name: MetadataSyncId},
        {Name: MetadataCodebasePath},
        {Name: MetadataFilePath},
        {Name: MetadataLanguage},
        {Name: MetadataRange},
        {Name: MetadataTokenCount},
        {Name: Content},
        {Name: "_additional", Fields: []graphql.Field{
            {Name: "certainty"},
            {Name: "distance"},
            {Name: "id"},
        }},
    }
    
    // 构建近向量查询
    nearVector := r.client.GraphQL().NearVectorArgBuilder().
        WithVector(embedQuery)
    
    // 执行GraphQL查询
    res, err := r.client.GraphQL().Get().
        WithClassName(r.className).
        WithFields(fields...).
        WithNearVector(nearVector).
        WithLimit(numDocuments).
        WithTenant(tenantName).
        Do(ctx)
    
    if err != nil {
        return nil, fmt.Errorf("failed to execute similarity search: %w", err)
    }
    
    // 验证响应
    if res == nil || res.Data == nil {
        return nil, fmt.Errorf("received empty response from Weaviate")
    }
    if err = CheckGraphQLResponseError(res); err != nil {
        return nil, fmt.Errorf("query weaviate failed: %w", err)
    }
    
    // 解析响应
    items, err := r.unmarshalSimilarSearchResponse(res, options.CodebasePath, options.ClientId, options.Authorization)
    if err != nil {
        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
    }
    
    return items, nil
}
```

### 3. 响应解析与源码获取

```go
func (r *weaviateWrapper) unmarshalSimilarSearchResponse(res *models.GraphQLResponse, codebasePath, clientId string, authorization string) ([]*types.SemanticFileItem, error) {
    // 获取数据
    data, ok := res.Data["Get"].(map[string]interface{})
    if !ok {
        return nil, fmt.Errorf("invalid response format: 'Get' field not found or has wrong type")
    }
    
    results, ok := data[r.className].([]interface{})
    if !ok {
        return nil, fmt.Errorf("invalid response format: class data not found or has wrong type")
    }
    
    items := make([]*types.SemanticFileItem, 0, len(results))
    
    // 收集需要获取源码的片段
    var snippets []CodeSnippetRequest
    for _, result := range results {
        obj, ok := result.(map[string]interface{})
        if !ok {
            continue
        }
        
        filePath := getStringValue(obj, MetadataFilePath)
        
        // 如果启用源码获取，收集片段信息
        if r.cfg.FetchSourceCode && filePath != "" && codebasePath != "" {
            var startLine, endLine int
            if rangeValue, ok := obj[MetadataRange].([]interface{}); ok && len(rangeValue) >= 2 {
                if first, ok := rangeValue[0].(float64); ok {
                    startLine = int(first)
                }
                if second, ok := rangeValue[2].(float64); ok {
                    endLine = int(second)
                }
            }
            
            fullPath := filepath.Join(codebasePath, filePath)
            snippets = append(snippets, CodeSnippetRequest{
                FilePath:  fullPath,
                StartLine: startLine,
                EndLine:   endLine,
            })
        }
    }
    
    // 批量获取代码片段内容
    var contentMap map[string]string
    if len(snippets) > 0 && codebasePath != "" {
        var err error
        contentMap, err = fetchCodeContentsBatch(context.Background(), r.cfg, clientId, codebasePath, snippets, authorization)
        if err != nil {
            return nil, fmt.Errorf("批量获取代码片段失败: %w", err)
        }
    }
    
    // 构建最终结果
    for _, result := range results {
        obj, ok := result.(map[string]interface{})
        if !ok {
            continue
        }
        
        additional, ok := obj["_additional"].(map[string]interface{})
        if !ok {
            continue
        }
        
        content := ""
        filePath := getStringValue(obj, MetadataFilePath)
        
        // 使用获取到的源码内容
        if r.cfg.FetchSourceCode && filePath != "" && codebasePath != "" {
            var startLine, endLine int
            if rangeValue, ok := obj[MetadataRange].([]interface{}); ok && len(rangeValue) >= 2 {
                if first, ok := rangeValue[0].(float64); ok {
                    startLine = int(first)
                }
                if second, ok := rangeValue[2].(float64); ok {
                    endLine = int(second)
                }
            }
            
            fullPath := filepath.Join(codebasePath, filePath)
            key := fmt.Sprintf("%s:%d-%d", fullPath, startLine, endLine)
            if fetchedContent, exists := contentMap[key]; exists && fetchedContent != "" {
                content = fetchedContent
            }
        }
        
        item := &types.SemanticFileItem{
            Content:  content,
            FilePath: filePath,
            Score:    float32(getFloatValue(additional, "certainty")),
        }
        
        items = append(items, item)
    }
    
    return items, nil
}
```

### 4. 批量代码片段获取

```go
func fetchCodeContentsBatch(ctx context.Context, cfg config.VectorStoreConf, clientId, codebasePath string, snippets []CodeSnippetRequest, authorization string) (map[string]string, error) {
    if len(snippets) == 0 {
        return nil, nil
    }
    
    // 构建请求体
    request := CodeSnippetsBatchRequest{
        ClientId:      clientId,
        WorkspacePath: codebasePath,
        CodeSnippets:  snippets,
    }
    
    jsonData, err := json.Marshal(request)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal request: %w", err)
    }
    
    // 创建HTTP请求
    req, err := http.NewRequestWithContext(ctx, "POST", cfg.BaseURL, bytes.NewBuffer(jsonData))
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }
    
    // 设置请求头
    req.Header.Set("Content-Type", "application/json")
    if authorization != "" {
        req.Header.Set("Authorization", authorization)
    }
    
    // 发送请求
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, fmt.Errorf("failed to fetch code contents batch: %w", err)
    }
    defer resp.Body.Close()
    
    // 检查响应状态
    if resp.StatusCode != http.StatusOK {
        errorBody, err := io.ReadAll(resp.Body)
        if err != nil {
            return nil, fmt.Errorf("unexpected status code: %d, failed to read error response: %w", resp.StatusCode, err)
        }
        return nil, fmt.Errorf("unexpected status code: %d, response: %s", resp.StatusCode, string(errorBody))
    }
    
    // 解析响应
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("failed to read response body: %w", err)
    }
    
    var batchResponse CodeSnippetsBatchResponse
    if err := json.Unmarshal(body, &batchResponse); err != nil {
        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
    }
    
    if !batchResponse.Success {
        return nil, fmt.Errorf("API request failed: %s", batchResponse.Message)
    }
    
    // 构建内容映射
    contentMap := make(map[string]string)
    for _, snippet := range batchResponse.Data.List {
        key := fmt.Sprintf("%s:%d-%d", snippet.FilePath, snippet.StartLine, snippet.EndLine)
        contentMap[key] = snippet.Content
    }
    
    return contentMap, nil
}
```

## 多租户实现细节

### 租户名称生成

```go
func (r *weaviateWrapper) generateTenantName(codebasePath string) (string, error) {
    if codebasePath == types.EmptyString {
        return types.EmptyString, ErrInvalidCodebasePath
    }
    
    // 使用MD5哈希生成32位十六进制字符串
    hash := md5.Sum([]byte(codebasePath))
    tenantName := hex.EncodeToString(hash[:])
    
    return tenantName, nil
}
```

### 租户隔离机制

1. **数据隔离**: 每个代码库路径对应唯一的租户名称
2. **自动创建**: 配置 `AutoTenantCreation: true` 实现租户自动创建
3. **查询过滤**: 所有查询都包含租户名称，确保数据隔离

## 错误处理机制

### 批量操作错误检查

```go
func CheckBatchErrors(resp *models.ObjectsGetResponse) error {
    if resp == nil {
        return fmt.Errorf("batch response is nil")
    }
    
    for _, obj := range resp.Objects {
        if obj.Result != nil && obj.Result.Errors != nil && len(obj.Result.Errors.Error) > 0 {
            var errMsg string
            for _, e := range obj.Result.Errors.Error {
                errMsg += e.Message + "; "
            }
            return fmt.Errorf("batch operation errors: %s", errMsg)
        }
    }
    
    return nil
}

func CheckBatchDeleteErrors(resp *models.BatchDeleteObjectsResponse) error {
    if resp == nil {
        return fmt.Errorf("batch delete response is nil")
    }
    
    if resp.DeleteResponse != nil && len(resp.DeleteResponse.Errors) > 0 {
        var errMsg string
        for _, e := range resp.DeleteResponse.Errors {
            errMsg += e.Message + "; "
        }
        return fmt.Errorf("batch delete errors: %s", errMsg)
    }
    
    return nil
}
```

### GraphQL 响应错误检查

```go
func CheckGraphQLResponseError(res *models.GraphQLResponse) error {
    if res == nil {
        return fmt.Errorf("GraphQL response is nil")
    }
    
    if len(res.Errors) > 0 {
        var errMsg string
        for _, e := range res.Errors {
            errMsg += e.Message + "; "
        }
        return fmt.Errorf("GraphQL errors: %s", errMsg)
    }
    
    return nil
}
```

## 性能优化策略

### 1. 批量操作优化

- **批量插入**: 使用 `ObjectsBatcher` 一次性插入多个对象
- **批量删除**: 使用 `ObjectsBatchDeleter` 批量删除对象
- **批量源码获取**: 通过单个HTTP请求获取多个代码片段

### 2. 分页查询优化

```go
func (r *weaviateWrapper) GetCodebaseRecords(ctx context.Context, codebaseId int32, codebasePath string) ([]*types.CodebaseRecord, error) {
    // ... 前置代码
    
    var allRecords []*types.CodebaseRecord
    limit := 1000 // 每批获取1000条记录
    offset := 0
    
    for {
        // 执行分页查询
        res, err := r.client.GraphQL().Get().
            WithClassName(r.className).
            WithFields(fields...).
            WithWhere(codebaseFilter).
            WithLimit(limit).
            WithOffset(offset).
            WithTenant(tenantName).
            Do(ctx)
        
        if err != nil {
            return nil, fmt.Errorf("failed to get codebase records: %w", err)
        }
        
        // 解析响应
        records, err := r.unmarshalCodebaseRecordsResponse(res)
        if err != nil {
            return nil, fmt.Errorf("failed to unmarshal records response: %w", err)
        }
        
        if len(records) == 0 {
            break // 没有更多记录
        }
        
        allRecords = append(allRecords, records...)
        offset += limit
        
        if len(records) < limit {
            break // 已获取所有记录
        }
    }
    
    return allRecords, nil
}
```

### 3. 缓存策略

- **嵌入向量缓存**: 对相同的查询文本缓存嵌入向量
- **代码片段缓存**: 缓存已获取的代码片段内容
- **连接池管理**: 复用Weaviate客户端连接

## 监控与调试

### 详细调试日志

```go
func (r *weaviateWrapper) GetCodebaseRecords(ctx context.Context, codebaseId int32, codebasePath string) ([]*types.CodebaseRecord, error) {
    // 添加调试日志
    fmt.Printf("[DEBUG] GetCodebaseRecords - 开始执行，codebaseId: %d, codebasePath: %s\n", codebaseId, codebasePath)
    
    // 检查输入参数
    if codebaseId == 0 {
        fmt.Printf("[DEBUG] 警告: codebaseId 为 0，这可能不正确\n")
    }
    if codebasePath == "" {
        fmt.Printf("[DEBUG] 警告: codebasePath 为空字符串\n")
    }
    
    // 检查Weaviate连接状态
    live, err := r.client.Misc().LiveChecker().Do(ctx)
    if err != nil {
        fmt.Printf("[DEBUG] Weaviate 连接检查失败: %v\n", err)
    } else {
        fmt.Printf("[DEBUG] Weaviate 连接状态: %v\n", live)
    }
    
    // ... 其余代码
    
    // 分析查询结果
    if len(allRecords) == 0 {
        fmt.Printf("[DEBUG] 警告: 查询结果为空，可能的原因:\n")
        fmt.Printf("[DEBUG] 1. Weaviate 中没有 codebaseId %d 的数据\n", codebaseId)
        fmt.Printf("[DEBUG] 2. Tenant %s 不存在或没有权限访问\n", tenantName)
        fmt.Printf("[DEBUG] 3. 过滤器条件过于严格\n")
        fmt.Printf("[DEBUG] 4. Weaviate 连接配置有问题\n")
        fmt.Printf("[DEBUG] 5. 类名 %s 不正确\n", r.className)
    }
    
    return allRecords, nil
}
```

### 性能监控

```go
func (r *weaviateWrapper) SimilaritySearch(ctx context.Context, query string, numDocuments int, options Options) ([]*types.SemanticFileItem, error) {
    start := time.Now()
    defer func() {
        tracer.WithTrace(ctx).Infof("similarity search completed, cost %d ms", time.Since(start).Milliseconds())
    }()
    
    // ... 搜索逻辑
    
    return items, nil
}
```

## 扩展性设计

### 1. 插件化架构

- **Embedder接口**: 支持不同的嵌入模型实现
- **Reranker接口**: 支持不同的重排序算法
- **状态管理器**: 支持不同的状态后端

### 2. 配置驱动

所有功能都通过配置文件驱动，无需修改代码即可调整行为：

```go
type VectorStoreConf struct {
    Type     string
    Weaviate struct {
        Endpoint   string
        APIKey     string
        ClassName  string
        Timeout    time.Duration
        MaxDocuments int
    }
    FetchSourceCode bool
    BaseURL        string
    Embedder       EmbedderConf
}
```

### 3. 向后兼容

- **接口稳定性**: 保持Store接口的稳定性
- **版本兼容**: 支持多个版本的Weaviate客户端
- **配置迁移**: 支持旧版本配置的自动迁移