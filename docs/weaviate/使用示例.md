# Weaviate 使用示例文档

## 基础使用示例

### 1. 初始化 Weaviate 存储

```go
package main

import (
    "context"
    "log"
    "time"
    
    "github.com/zgsm-ai/codebase-indexer/internal/config"
    "github.com/zgsm-ai/codebase-indexer/internal/store/vector"
    "github.com/zgsm-ai/codebase-indexer/internal/store/redis"
)

func main() {
    // 创建向量存储配置
    vectorStoreConfig := config.VectorStoreConf{
        Type: "weaviate",
        Weaviate: struct {
            Endpoint   string
            APIKey     string
            ClassName  string
            Timeout    time.Duration
            MaxDocuments int
        }{
            Endpoint:     "localhost:8080",
            APIKey:       "", // 如果需要认证，请提供API密钥
            ClassName:    "CodeChunk",
            Timeout:      30 * time.Second,
            MaxDocuments: 100,
        },
        FetchSourceCode: true,
        BaseURL:         "http://localhost:8081/api/code-snippet",
    }
    
    // 创建嵌入器和重排序器
    embedder := &MockEmbedder{} // 实际使用时替换为真实的嵌入器
    reranker := &MockReranker{} // 实际使用时替换为真实的重排序器
    
    // 创建向量存储
    store, err := vector.NewVectorStore(vectorStoreConfig, embedder, reranker)
    if err != nil {
        log.Fatalf("Failed to create vector store: %v", err)
    }
    defer store.Close()
    
    // 使用存储进行操作...
}
```

### 2. 创建带有状态管理器的存储

```go
func createStoreWithStatusManager() {
    // 创建Redis状态管理器
    redisClient := redis.NewRedisClient(&redis.Config{
        Addr:     "localhost:6379",
        Password: "",
        DB:       0,
    })
    
    statusManager := redis.NewStatusManager(redisClient)
    
    // 创建带有状态管理器的向量存储
    store, err := vector.NewVectorStoreWithStatusManager(
        vectorStoreConfig,
        embedder,
        reranker,
        statusManager,
        "request-123", // 请求ID
    )
    if err != nil {
        log.Fatalf("Failed to create vector store with status manager: %v", err)
    }
    
    // 使用存储进行操作...
}
```

## 数据操作示例

### 1. 插入代码块

```go
func insertCodeChunks(store vector.Store) {
    ctx := context.Background()
    
    // 准备代码块数据
    codeChunks := []*types.CodeChunk{
        {
            CodebaseId:   1,
            CodebasePath: "/path/to/my-project",
            CodebaseName: "my-awesome-project",
            FilePath:     "src/main.go",
            Content:      []byte(`package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}`),
            Language:   "go",
            Range:      []int{1, 9},
            TokenCount: 25,
        },
        {
            CodebaseId:   1,
            CodebasePath: "/path/to/my-project",
            CodebaseName: "my-awesome-project",
            FilePath:     "src/utils.go",
            Content:      []byte(`package main

import "strings"

func toUpper(s string) string {
    return strings.ToUpper(s)
}`),
            Language:   "go",
            Range:      []int{1, 7},
            TokenCount: 20,
        },
    }
    
    // 插入选项
    options := vector.Options{
        CodebaseId:    1,
        SyncId:        1,
        RequestId:     "sync-001",
        CodebasePath:  "/path/to/my-project",
        CodebaseName:  "my-awesome-project",
        TotalFiles:    2,
        ClientId:      "client-123",
        Authorization: "Bearer token-abc123",
    }
    
    // 插入代码块
    err := store.InsertCodeChunks(ctx, codeChunks, options)
    if err != nil {
        log.Printf("Failed to insert code chunks: %v", err)
        return
    }
    
    log.Println("Code chunks inserted successfully")
}
```

### 2. 更新代码块

```go
func updateCodeChunks(store vector.Store) {
    ctx := context.Background()
    
    // 准备更新的代码块
    updatedChunks := []*types.CodeChunk{
        {
            CodebaseId:   1,
            CodebasePath: "/path/to/my-project",
            CodebaseName: "my-awesome-project",
            FilePath:     "src/main.go",
            Content:      []byte(`package main

import "fmt"

func main() {
    fmt.Println("Hello, Updated World!")
    fmt.Println("This is an updated version")
}`),
            Language:   "go",
            Range:      []int{1, 10},
            TokenCount: 35,
        },
    }
    
    options := vector.Options{
        CodebaseId:   1,
        CodebasePath: "/path/to/my-project",
        CodebaseName: "my-awesome-project",
    }
    
    // 使用Upsert更新代码块（先删除再插入）
    err := store.UpsertCodeChunks(ctx, updatedChunks, options)
    if err != nil {
        log.Printf("Failed to update code chunks: %v", err)
        return
    }
    
    log.Println("Code chunks updated successfully")
}
```

### 3. 更新文件路径

```go
func updateFilePaths(store vector.Store) {
    ctx := context.Background()
    
    // 准备路径更新
    pathUpdates := []*types.CodeChunkPathUpdate{
        {
            CodebaseId:   1,
            OldFilePath:  "src/utils.go",
            NewFilePath:  "src/helpers/string_utils.go",
        },
        {
            CodebaseId:   1,
            OldFilePath:  "src/main.go",
            NewFilePath:  "src/cmd/main.go",
        },
    }
    
    options := vector.Options{
        CodebaseId:   1,
        CodebasePath: "/path/to/my-project",
    }
    
    // 执行路径更新
    err := store.UpdateCodeChunksPaths(ctx, pathUpdates, options)
    if err != nil {
        log.Printf("Failed to update file paths: %v", err)
        return
    }
    
    log.Println("File paths updated successfully")
}
```

## 搜索查询示例

### 1. 相似性搜索

```go
func similaritySearch(store vector.Store) {
    ctx := context.Background()
    
    query := "如何在Go中实现字符串反转"
    numDocuments := 5
    
    options := vector.Options{
        CodebaseId:    1,
        CodebasePath:  "/path/to/my-project",
        ClientId:      "client-123",
        Authorization: "Bearer token-abc123",
    }
    
    // 执行相似性搜索
    results, err := store.SimilaritySearch(ctx, query, numDocuments, options)
    if err != nil {
        log.Printf("Failed to perform similarity search: %v", err)
        return
    }
    
    // 处理搜索结果
    log.Printf("Found %d similar code chunks:", len(results))
    for i, item := range results {
        log.Printf("Result %d:", i+1)
        log.Printf("  File: %s", item.FilePath)
        log.Printf("  Score: %.4f", item.Score)
        log.Printf("  Content: %s", truncateString(item.Content, 100))
        log.Println("---")
    }
}

func truncateString(s string, maxLen int) string {
    if len(s) <= maxLen {
        return s
    }
    return s[:maxLen] + "..."
}
```

### 2. 完整查询（包含重排序）

```go
func fullQuery(store vector.Store) {
    ctx := context.Background()
    
    query := "Go语言中的并发编程模式"
    topK := 3
    
    options := vector.Options{
        CodebaseId:    1,
        CodebasePath:  "/path/to/my-project",
        ClientId:      "client-123",
        Authorization: "Bearer token-abc123",
    }
    
    // 执行完整查询（包含重排序）
    results, err := store.Query(ctx, query, topK, options)
    if err != nil {
        log.Printf("Failed to perform query: %v", err)
        return
    }
    
    // 处理查询结果
    log.Printf("Top %d results for query '%s':", topK, query)
    for i, item := range results {
        log.Printf("Rank %d:", i+1)
        log.Printf("  File: %s", item.FilePath)
        log.Printf("  Score: %.4f", item.Score)
        log.Printf("  Content preview: %s", truncateString(item.Content, 150))
        log.Println("---")
    }
}
```

### 3. 获取代码库摘要

```go
func getCodebaseSummary(store vector.Store) {
    ctx := context.Background()
    
    codebaseId := int32(1)
    codebasePath := "/path/to/my-project"
    
    // 获取索引摘要
    summary, err := store.GetIndexSummary(ctx, codebaseId, codebasePath)
    if err != nil {
        log.Printf("Failed to get index summary: %v", err)
        return
    }
    
    // 显示摘要信息
    log.Printf("Codebase Summary:")
    log.Printf("  Total Files: %d", summary.TotalFiles)
    log.Printf("  Total Chunks: %d", summary.TotalChunks)
    log.Printf("  Average Chunks per File: %.2f", 
        float64(summary.TotalChunks)/float64(summary.TotalFiles))
}
```

### 4. 获取代码库记录

```go
func getCodebaseRecords(store vector.Store) {
    ctx := context.Background()
    
    codebaseId := int32(1)
    codebasePath := "/path/to/my-project"
    
    // 获取所有代码库记录
    records, err := store.GetCodebaseRecords(ctx, codebaseId, codebasePath)
    if err != nil {
        log.Printf("Failed to get codebase records: %v", err)
        return
    }
    
    // 统计信息
    languageCount := make(map[string]int)
    totalTokens := 0
    
    // 处理记录
    log.Printf("Found %d codebase records:", len(records))
    for _, record := range records {
        languageCount[record.Language]++
        totalTokens += record.TokenCount
        
        log.Printf("  File: %s", record.FilePath)
        log.Printf("    Language: %s", record.Language)
        log.Printf("    Token Count: %d", record.TokenCount)
        log.Printf("    Range: %v", record.Range)
        log.Printf("    Last Updated: %s", record.LastUpdated.Format("2006-01-02 15:04:05"))
    }
    
    // 显示统计信息
    log.Println("\nStatistics:")
    log.Printf("  Total Tokens: %d", totalTokens)
    log.Println("  Language Distribution:")
    for lang, count := range languageCount {
        log.Printf("    %s: %d files", lang, count)
    }
}
```

## 删除操作示例

### 1. 删除特定代码块

```go
func deleteCodeChunks(store vector.Store) {
    ctx := context.Background()
    
    // 准备要删除的代码块
    chunksToDelete := []*types.CodeChunk{
        {
            CodebaseId: 1,
            FilePath:   "src/old_file.go",
        },
        {
            CodebaseId: 1,
            FilePath:   "src/deprecated.go",
        },
    }
    
    options := vector.Options{
        CodebaseId:   1,
        CodebasePath: "/path/to/my-project",
    }
    
    // 删除代码块
    err := store.DeleteCodeChunks(ctx, chunksToDelete, options)
    if err != nil {
        log.Printf("Failed to delete code chunks: %v", err)
        return
    }
    
    log.Println("Code chunks deleted successfully")
}
```

### 2. 删除整个代码库

```go
func deleteCodebase(store vector.Store) {
    ctx := context.Background()
    
    codebaseId := int32(1)
    codebasePath := "/path/to/my-project"
    
    // 删除整个代码库
    err := store.DeleteByCodebase(ctx, codebaseId, codebasePath)
    if err != nil {
        log.Printf("Failed to delete codebase: %v", err)
        return
    }
    
    log.Printf("Codebase %d deleted successfully", codebaseId)
}
```

## 高级使用示例

### 1. 批量处理大型代码库

```go
func processLargeCodebase(store vector.Store) {
    ctx := context.Background()
    
    // 模拟处理大型代码库的多个文件
    files := []string{
        "src/main.go",
        "src/utils.go",
        "src/config/config.go",
        "src/handlers/api.go",
        "src/models/user.go",
        "src/services/auth.go",
        // ... 更多文件
    }
    
    batchSize := 10 // 每批处理10个文件
    totalFiles := len(files)
    
    for i := 0; i < totalFiles; i += batchSize {
        end := i + batchSize
        if end > totalFiles {
            end = totalFiles
        }
        
        batch := files[i:end]
        
        // 为当前批次创建代码块
        chunks := make([]*types.CodeChunk, len(batch))
        for j, file := range batch {
            chunks[j] = &types.CodeChunk{
                CodebaseId:   2,
                CodebasePath: "/path/to/large-project",
                CodebaseName: "large-project",
                FilePath:     file,
                Content:      []byte(fmt.Sprintf("// Content of %s\npackage main\n\nfunc main() {}", file)),
                Language:     "go",
                Range:        []int{1, 5},
                TokenCount:   15,
            }
        }
        
        options := vector.Options{
            CodebaseId:   2,
            SyncId:       int32(i/batchSize + 1),
            RequestId:    fmt.Sprintf("batch-%d", i/batchSize + 1),
            CodebasePath: "/path/to/large-project",
            CodebaseName: "large-project",
            TotalFiles:   totalFiles,
            ClientId:     "client-123",
        }
        
        // 插入当前批次
        err := store.InsertCodeChunks(ctx, chunks, options)
        if err != nil {
            log.Printf("Failed to insert batch %d: %v", i/batchSize + 1, err)
            continue
        }
        
        log.Printf("Processed batch %d/%d (%d files)", i/batchSize + 1, (totalFiles+batchSize-1)/batchSize, len(batch))
        
        // 添加小延迟避免过载
        time.Sleep(100 * time.Millisecond)
    }
    
    log.Println("Large codebase processing completed")
}
```

### 2. 带有进度监控的索引操作

```go
func indexWithProgress(store vector.Store) {
    ctx := context.Background()
    
    // 创建Redis状态管理器
    redisClient := redis.NewRedisClient(&redis.Config{
        Addr:     "localhost:6379",
        Password: "",
        DB:       0,
    })
    
    statusManager := redis.NewStatusManager(redisClient)
    
    // 创建带有状态管理器的存储
    vectorStoreConfig := config.VectorStoreConf{
        Type: "weaviate",
        Weaviate: struct {
            Endpoint   string
            APIKey     string
            ClassName  string
            Timeout    time.Duration
            MaxDocuments int
        }{
            Endpoint:     "localhost:8080",
            ClassName:    "CodeChunk",
            Timeout:      30 * time.Second,
            MaxDocuments: 100,
        },
        FetchSourceCode: true,
        BaseURL:         "http://localhost:8081/api/code-snippet",
    }
    
    store, err := vector.NewVectorStoreWithStatusManager(
        vectorStoreConfig,
        &MockEmbedder{},
        &MockReranker{},
        statusManager,
        "index-request-123",
    )
    if err != nil {
        log.Fatalf("Failed to create vector store with status manager: %v", err)
    }
    
    // 准备要索引的代码块
    chunks := generateCodeChunks() // 假设这个函数生成代码块
    
    options := vector.Options{
        CodebaseId:   3,
        SyncId:       1,
        RequestId:    "index-request-123",
        CodebasePath: "/path/to/monitored-project",
        CodebaseName: "monitored-project",
        TotalFiles:   len(chunks),
        ClientId:     "client-123",
    }
    
    // 启动goroutine监控进度
    go func() {
        for {
            status, err := statusManager.GetStatus(ctx, "index-request-123")
            if err != nil {
                log.Printf("Failed to get status: %v", err)
                continue
            }
            
            log.Printf("Indexing progress: %d/%d files (%.1f%%)", 
                status.ProcessedFiles, status.TotalFiles,
                float64(status.ProcessedFiles)/float64(status.TotalFiles)*100)
            
            if status.ProcessedFiles >= status.TotalFiles {
                break
            }
            
            time.Sleep(1 * time.Second)
        }
    }()
    
    // 执行索引操作
    err = store.InsertCodeChunks(ctx, chunks, options)
    if err != nil {
        log.Printf("Failed to index code chunks: %v", err)
        return
    }
    
    log.Println("Indexing completed successfully")
}
```

### 3. 多语言代码搜索示例

```go
func multiLanguageSearch(store vector.Store) {
    ctx := context.Background()
    
    // 准备不同语言的查询
    queries := []struct {
        language string
        query    string
    }{
        {"go", "如何实现HTTP服务器"},
        {"python", "如何创建装饰器"},
        {"javascript", "如何使用Promise处理异步操作"},
        {"java", "如何实现单例模式"},
    }
    
    options := vector.Options{
        CodebaseId:    4,
        CodebasePath:  "/path/to/multi-lang-project",
        ClientId:      "client-123",
        Authorization: "Bearer token-abc123",
    }
    
    for _, q := range queries {
        log.Printf("Searching for %s query: %s", q.language, q.query)
        
        // 执行搜索
        results, err := store.Query(ctx, q.query, 3, options)
        if err != nil {
            log.Printf("Failed to search for %s: %v", q.language, err)
            continue
        }
        
        log.Printf("Found %d results for %s:", len(results), q.language)
        for i, item := range results {
            log.Printf("  Result %d: %s (score: %.4f)", i+1, item.FilePath, item.Score)
        }
        log.Println("---")
    }
}
```

## 错误处理示例

### 1. 完善的错误处理

```go
func robustOperations(store vector.Store) {
    ctx := context.Background()
    
    // 错误处理函数
    handleError := func(operation string, err error) {
        if err != nil {
            log.Printf("Error in %s: %v", operation, err)
            // 可以在这里添加重试逻辑、通知机制等
        }
    }
    
    // 带有错误检查的插入操作
    chunks := []*types.CodeChunk{
        {
            CodebaseId:   5,
            CodebasePath: "/path/to/test-project",
            CodebaseName: "test-project",
            FilePath:     "test.go",
            Content:      []byte("package main\n\nfunc main() {}"),
            Language:     "go",
            Range:        []int{1, 3},
            TokenCount:   10,
        },
    }
    
    options := vector.Options{
        CodebaseId:   5,
        CodebasePath: "/path/to/test-project",
    }
    
    // 尝试插入，带有重试机制
    maxRetries := 3
    for i := 0; i < maxRetries; i++ {
        err := store.InsertCodeChunks(ctx, chunks, options)
        if err == nil {
            log.Println("Insertion successful")
            break
        }
        
        handleError(fmt.Sprintf("insert attempt %d", i+1), err)
        
        if i < maxRetries-1 {
            log.Printf("Retrying in %d seconds...", (i+1)*2)
            time.Sleep(time.Duration((i+1)*2) * time.Second)
        } else {
            log.Println("Max retries reached, giving up")
        }
    }
    
    // 带有错误检查的搜索操作
    _, err := store.Query(ctx, "test query", 5, options)
    if err != nil {
        handleError("search operation", err)
        
        // 根据错误类型采取不同的恢复策略
        if strings.Contains(err.Error(), "connection refused") {
            log.Println("Weaviate connection issue, checking service status...")
            // 可以在这里添加服务健康检查逻辑
        } else if strings.Contains(err.Error(), "timeout") {
            log.Println("Operation timeout, consider increasing timeout value")
            // 可以在这里调整超时设置
        }
    }
}
```

### 2. 资源清理示例

```go
func cleanupOperations(store vector.Store) {
    ctx := context.Background()
    
    // 清理函数
    defer func() {
        if r := recover(); r != nil {
            log.Printf("Recovered from panic: %v", r)
            // 可以在这里添加清理逻辑
        }
    }()
    
    // 使用defer确保资源释放
    defer store.Close()
    
    // 执行一系列操作
    codebaseId := int32(6)
    codebasePath := "/path/to/cleanup-project"
    
    // 1. 先检查代码库是否存在
    summary, err := store.GetIndexSummary(ctx, codebaseId, codebasePath)
    if err != nil {
        log.Printf("Failed to get summary: %v", err)
        return
    }
    
    if summary == nil || summary.TotalFiles == 0 {
        log.Println("Codebase does not exist or is empty")
        return
    }
    
    log.Printf("Found codebase with %d files, %d chunks", summary.TotalFiles, summary.TotalChunks)
    
    // 2. 执行清理操作
    err = store.DeleteByCodebase(ctx, codebaseId, codebasePath)
    if err != nil {
        log.Printf("Failed to delete codebase: %v", err)
        return
    }
    
    log.Println("Codebase cleaned up successfully")
}
```

这些示例展示了Weaviate向量存储的各种使用场景，从基本的CRUD操作到高级的批量处理和错误处理。根据实际需求，可以灵活调整这些示例代码。